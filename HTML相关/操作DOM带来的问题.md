DOM（Document Object Model，文档对象模型）是 JavaScript 操作 HTML 的接口，大部分前端功能都需要借助 DOM 来实现，比如：

- 动态渲染列表、表格表单数据；

- 监听点击、提交事件；

- 懒加载一些脚本或样式文件；

- 实现动态展开树组件，表单组件级联等这类复杂的操作。


DOM 主要由 3 个部分组成：

- DOM 节点

- DOM 事件

- 选择区域

## 为什么操作DOM耗时

### 线程切换

浏览器的渲染引擎和 JavaScript 引擎是互斥的，某时刻只有一个引擎在运行，另一个会被阻塞。**操作系统在进行线程切换的时候需要保存上一个线程执行时的状态信息并读取下一个线程的状态信息，俗称上下文切换。而这个操作相对而言是比较耗时的。**

每次 DOM 操作就会引发线程的上下文切换——从 JavaScript 引擎切换到渲染引擎执行对应操作，然后再切换回 JavaScript 引擎继续执行，这就带来了**性能损耗**。单次切换消耗的时间是非常少的，但是如果频繁地大量切换，那么就会产生性能问题。

### 重新渲染

另一个更加耗时的因素是元素及样式变化引起的再次渲染，在渲染过程中最耗时的两个步骤为**重排**（Reflow）与**重绘**（Repaint）。

浏览器在渲染页面时会将 HTML 和 CSS 分别解析成 DOM 树和 CSSOM 树，然后合并进行排布，再绘制成我们可见的页面。如果在操作 DOM 时涉及到元素、样式的修改，就会引起渲染引擎重新计算样式生成 CSSOM 树，同时还有可能触发对元素的重新排布（简称“重排”）和重新绘制（简称“重绘”）。

可能会影响到其他元素排布的操作就会引起**重排**，继而引发重绘，比如：

- 修改元素边距、大小

- 添加、删除元素

- 改变窗口大小


与之相反的操作则只会引起**重绘**，比如：

- 设置背景图片

- 修改字体颜色

- 改变 visibility 属性值


重排渲染耗时明显高于重绘，同时两者的 Painting 事件耗时接近，也印证了重排会导致重绘。

## 如何高效操作DOM

### 批量操作元素

比如说要创建 1 万个 div 元素，在循环中直接创建再添加到父元素上耗时会非常多。如果采用字符串拼接的形式，先将 1 万个 div 元素的 html 字符串拼接成一个完整字符串，然后赋值给 body 元素的 innerHTML 属性就可以明显减少耗时。

### 缓存元素集合

比如将通过选择器函数获取到的 DOM 元素赋值给变量，之后通过变量操作而不是再次使用选择器函数来获取。

### 其他

- 尽量不要使用复杂的匹配规则和复杂的样式，从而减少渲染引擎计算样式规则生成 CSSOM 树的时间；

- 尽量减少重排和重绘影响的区域；

- 使用 CSS3 特性来实现动画效果。
- 利用绝对定位 脱离文档流，这样操作定位里面的内容不会引起外部的重排

## 虚拟DOM

虚拟DOM 的作用有以下两个。

**优化性能** 。DOM 操作是比较耗时的，对于大量、频繁的 DOM 操作，如果先在 JavaScript 中模拟进行，然后再通过计算比对，找到真正需要更新的节点，这样就有可能减少不必要的 DOM 操作，从而提升渲染性能。但并不是所有的 DOM 操作都能通过虚拟 DOM 提升性能，比如单次删除某个节点，直接操作 DOM 肯定比虚拟 DOM 计算比对之后再删除要快。总体而言， 虚拟 DOM 提升了 DOM 操作的性能下限，降低了 DOM 操作的性能上限。 所以会看到一些对渲染性能要求比较高的场景，比如在线文档、表格编辑，还是会使用原生 DOM 操作。

**跨平台** 。由于虚拟 DOM 以 JavaScript 对象为基础，所以可根据不同的运行环境进行代码转换（比如浏览器、服务端、原生应用等），这使得它具有了跨平台的能力。