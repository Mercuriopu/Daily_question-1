## HTTP历史

> 时势造英雄，英雄亦造实事。

### 史前时期

20世纪60年代，美国国防部高等研究计划部署（ARPA）建立了 ARPA 网，它有四个分布在各地的结点，被认为是如今互联网的”始祖“。

然后在 70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。由于具有良好的分层结构和稳定的性能，TCP/IP 协议迅速战胜其他竞争对手流行起来，并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入。

### 创世纪

1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。

1. URI：即统一资源标识符，作为互联网上资源的唯一身份；

2. HTML：即超文本标记语言，描述超文本文档；

3. HTTP：即超文本传输协议，用来传输超

基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。

所以在这一年，HTTP 诞生了。

### HTTP/0.9

- 这个时代，计算机处理能力低，存储容量小，网速慢。网络上绝大多数资源是纯文本，很多通信协议也都使用纯文本。
- 受时代限制，这个时期的HTTP结构简单，为了便于服务器和客户端处理，采用了纯文本格式。只允许“GET”从服务器获取HTML文档，且在响应请求后立即关闭连接，功能有限。
- HTTP/0.9 虽然简单，但其作为一个原型，充分验证了Web服务器的可行性。

### HTTP/1.0

93 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，95 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。这些技术促进了HTTP发展。

1. 增加了 HEAD、POST 等新方法；

2. 增加了响应状态码，标记可能的错误原因；

3. 引入了协议版本号概念；

4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；

5. 传输的数据不再仅限于文本

**但 HTTP/1.0 并不是一个“标准”**。

### HTTP/1.1

1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。最终IE胜出。“浏览器大战”极大地推进了Web发展，HTTP/1.0 也在这个过程中经受了实践检验。

于是在1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。

HTTP/1.1 主要的变更点有：

1. 增加了 PUT、DELETE 等新的方法；

2. 增加了缓存管理和控制；

3. 明确了连接管理，允许持久连接；

4. 允许响应数据分块（chunked），利于传输大文件；

5. 强制要求 Host 头，让互联网主机托管成为

### HTTP/2

HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年的“快乐时光”，更涌现出了 Facebook、Twitter、淘宝、京东等互联网新贵。

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

1. 二进制协议，不再是纯文本；

2. 可发起多个请求，废弃了 1.1 里的管道；

3. 使用专用算法压缩头部，减少数据传输量；

4. 允许服务器主动向客户端推送数据；

5. 增强了安全性，“事实上”要求加密

### HTTP/3

- 2018年，HTTP/3正式进入标准化制定阶段。

### 小结

1. HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文；

2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；

3. HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；

4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；

5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；

6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展



## HTTP是什么

> HTTP 就是**超文本传输协议**，即 HyperText Transfer Protocol。

**协议**

- 协议必须有两个或多个参与者，即“协”。
- 协议是对参与者的一种行为约定和规范，即“议”。
- 协议应该包括语法、语义、同步规则和错误处理。
- 第一层含义：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

**传输**："A<===>B"

- HTTP是一个“**双向协议**”
- 数据传输过程中可以存在“**中间人**”，即“A<=>X<=>Y<=>B"，这些”中间人“也都遵从HTTP协议，只要不打扰基本数据传输，就可以添加任意的额外功能，如安全验证、数据压缩、编码转换等，优化整个传输过程。
- 第二层含义： HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 

**超文本**

- 是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

有上面三个概念，可以给出更精确的定义：**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**。

**HTTP不是什么？**

- HTTP不是互联网。（HTTP是构建互联网的一部分）
- HTTP不是编程语言。
- HTTP不是HTML。
- HTTP不是一个孤立的协议。（HTTP通常跑在TCP/IP协议栈之上）

**HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。**



### 关于域名

### 域名

- 域名是一个有层次的结构，是一串用"."分隔的多个单词，最右边被称为“顶级域名”，然后是“二级域名”，层级关系依次向左依次降低。
- 最左边是主机名，通常用来表明主机用途。如“www"表示提供万维网服务、”mail"表示提供邮件服务。但也并非绝对。

- 域名不仅能代替IP，还有其他用途。比如在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：

  ```js
  server{
      listen 80;
      server_name back.sampsonky.top;
      ...
  }
  ```

- 域名本质上还是个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识。



### 域名的解析

**域名解析**：域名  ---> IP地址。通过DNS完成。

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；

2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；

3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。

<img src="C:\Users\小新的光屁屁超人\Desktop\KY的HTTP笔记【老婆大人勿删】\images\DNS.png" alt="DNS" style="zoom:80%;" />

任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。

**缓存**（一种用来减轻域名解析的压力，并且能够更快地获取结果的手段）

- 首先，许多大公司、网络运行商都会建立自己的 DNS 服务器（非权威域名服务器），作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些服务器可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有CloudFlare 的“1.1.1.1”等等。

- 其次，**操作系统**也会对 DNS 解析结果进行缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。

- 另外，操作系统里还有一个特殊的**“主机映射”文件**，通常是一个可编辑的文本，在 Linux里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS记录，就会找这个文件。

- 在 Nginx 中有一条配置指令“resolver”，用来配置DNS服务器，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。

  ```nginx
  resover 8.8.8.8 valid=30s; #指定Google的DNS，缓存30s
  ```

**负载均衡**

- 因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。
- 域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。

## HTTP 报文

HTTP协议的请求报文和响应报文结构基本相同，由以下部分组成：

- 起始行（start line）：描述请求或响应的基本信息。
- 头部字段集合（header）：使用 key-value 形式更详细地说明报文。
- 空行：用来区分开头部和实体。
- 消息正文（entity）：实际传输地数据，它不一定是纯文本，可以是图片、视频等二进制数据。

这其中前两部分起始行和头部字段经常又合称为“**请求头**“或”**响应头**“，消息正文又称为”**实体**”（body）。

<img src="images\HTTP报文.png" alt="HTTP报文" style="zoom:50%;" />

例如：

<img src="images\HTTP报文例子.png" alt="HTTP报文例子" style="zoom:50%;" />

**请求行（request line）**：请求报文的起始行

- 简要地描述了客户端想要如何操作服务器端的资源。
- 由三部分构成：
  - 请求方法：是一个动词，如 GET/POST， 表示对资源的操作
  - 请求目标：通常是一个 URI，标记了请求方法要操作的资源
  - 版本号：表示报文使用的HTTP版本协议
- `GET / HTTP/1.1`

**状态行（status line）**：响应报文的起始行

- 服务器相应的状态。
- 三部分构成
  - 版本号：表示报文使用的 HTTP 版本协议
  - 状态码：三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误
  - 原因：座位数字状态码的补充，是更详细的解释文字。

- `HTTP/1.1 200 OK`

在起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**，严格遵循`ABNF`语法规范。 

**头部字段**

- key-value 形式
- 字段名不区分大小写
- 字段名不允许出现空格，可以使用‘-’，不可使用‘_'。
- 字段名后紧跟":"，不能有空格，但":"后可有空格。
- 字段顺序没有意义，可任意排序。
- 字段原则上不能重复，除非该字段本身语义允许，如 Set-Cookie。
- 请求头：请求行+头部字段；响应头：响应行+头部字段

<img src="images\请求头.png" alt="请求头" style="zoom:50%;" />

<img src="images\响应头.png" alt="响应头" style="zoom:50%;" />

**常用头部字段**

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；

3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；

4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

常见的有：

- **Host**字段，请求字段 ，唯一一个 HTTP/1.1 规范里要求必须出现的字段。告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”。
- **User-Agent**字段，请求字段，使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。
- **Data**字段，通用字段，但通常出现在响应头中，表示HTTP报文创建的时间，客户端可以使用这个时间再搭配其它字段决定缓存策略。
- **Server**字段，响应字段，告诉客户端当前正在提供 Web 服务的软件名称和版本号。
- **Content-Length**字段，实体字段，表示报文里body的长度，也就是实体数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。

## 请求方法

